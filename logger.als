// ===========================================================================
// SWEN90010 2019 - Assignment 2 Submission
// by <Ruizhi Li (941371), Wenzhou Wei (903836)>
// ===========================================================================

module logger
open util/ordering[State] as ord

// =========================== System State ==================================

// the type of network log messages
sig LogMessage {}

// meta information in the model that identifies the last action performed
abstract sig Action {}
one sig SendLogMessage, RecvLogMessage 
        extends Action {}

abstract sig AttackerAction extends Action {}
one sig DropMessage, FabricateMessage, ReplayMessage extends AttackerAction {}

// The system state
sig State {
  network : lone LogMessage,       // Network state: holds up to one message
  log     : seq LogMessage,        // The log: a sequence of messages
  last_action : lone Action,       // identifies the most recent action 
                                   // performed
}

// an axiom that restricts the model to never allow more than one messasge on
// the network at a time; a simplifying assumption to ease the analysis
fact {
  all s : State | lone s.network
}

// =========================== Initial State =================================

// The initial state of the system:
//   - empty network, 
//   - log is empty
pred Init[s : State] {
  no s.network and no s.log.elems and
  no s.last_action
}

// =========================== Actions =======================================

// Models the action in which a LogMessage log message is sent
// Precondition: the network is empty
// Postcondition: network contains a new message
//                last_action is SendLogMessage
//                and nothing else changes
pred send_log_message[s, s' : State] {
  no s.network and
  s'.last_action = SendLogMessage and
  s'.log = s.log and
  (some msg : LogMessage | 
    (s'.network = s.network + msg))
}

// Models the action in which a log message is received
// by the logger, causing the log to be updated
// and the message to be removed from the network.
// Precondition: exists some LogMessage message m on network
// Postcondition: contents of message m added to the log
//                message m is removed from the network
//                last_action is RecvLogMessage
pred recv_log_message[s, s' : State] {
  (some msg : LogMessage | 
      msg in s.network and s'.log = s.log.add[msg] and
      s'.network = s.network - msg) and
  s'.last_action = RecvLogMessage
}

// =========================== Attacker Actions ==============================

// Models the action in which a hacker drops a message from the network
// Precondition: exists some LogMessage message msg on the network
// Postcondition: message m is removed from the network
// 		last_action is DropMessage
// 		and nothing else changes
pred attacker_action_drop[s, s' : State] {
  (some msg : LogMessage | 
      msg in s.network and
      s'.network = s.network - msg) and
  s'.log = s.log and
  s'.last_action = DropMessage
}

// Models the action in which the attacker invents a new log message and injects it into the network,
// to be received by the Logging Service. 
// Precondition: the network is empty. 
// Postcondition: modify last_action to FabricateMessage,
// 		add a new message to the network,
// 		and nothing else changes
pred attacker_action_fabricate[s, s' : State] {
  no s.network and
  s'.last_action = FabricateMessage and
  s'.log = s.log and
  (some msg : LogMessage | 
    s'.network = s.network + msg
    )
}

// Models the action in which the attacker injects an old message onto the network,
// which has already presented on the network in some prior state of the model. 
// Precondition: the network is empty 
// 		and the choosen state's network is not empty.
// Postcondition: modify last_action to ReplayMessage  
// 		get one old Message and add it to the network
//		and nothing else changes
pred attacker_action_replay[s, s' : State] {
 no s.network and s'.log = s.log and 
 s'.last_action = ReplayMessage and 
 some prev_state : ord/prevs[s] | (
     #prev_state.network>0 and
     (s'.network = s.network + prev_state.network))
}

// =========================== State Transitions and Traces ==================

// State transitions occur via the various actions of the system above
// including those of the attacker.
pred state_transition[s, s' : State] {
  send_log_message[s,s']
  or recv_log_message[s,s']
  or attacker_action_drop[s,s']
  or attacker_action_fabricate[s,s']
  or attacker_action_replay[s,s']
}

// Define the linear ordering on states to be that generated by the
// state transitions above, defining execution traces to be sequences
// of states in which each state follows in the sequence from the last
// by a state transition.
fact state_transition_ord {
  all s: State, s': ord/next[s] {
    state_transition[s,s'] and s' != s
  }
}

// The initial state is first in the order, i.e. all execution traces
// that we model begin in the initial state described by the Init predicate
fact init_state {
  all s: ord/first {
    Init[s]
  }
}

// =========================== Properties ====================================

// An example assertion and check:
// Specifies that the log only grows, i.e. new things can get
// added to it but nothing is ever removed
assert log_only_grows {
  all s : State | all s' : ord/nexts[s] |
     some (s.log.elems) implies 
     (all idx : Int | idx < #(s.log) implies  s.log[idx] = s'.log[idx])
}

check log_only_grows for 10 expect 0

// According to the task description, there are 3 ways that satisfy the correct log requirements
// 1:  All the states only contain three legal actions which are SendLogMessage, RecvLogMessage and DropMessage.
//	 These actions are impossible to make the log out of order.
// 2:  If one state is FabricateMessage, there still have three ways to make the log legal, 
//      combined with the previous and the next state of the present one, the order will be:
//      a) DropMessage -> FabricateMessage -> RecvLogMessage and the Message dropped is equal to the message fabricated
//      b) DropMessage -> FabricateMessage -> DropMessage  
//              as the manipulated message is dropped after fabricated and one more message dropping is considered normal condition due to task description
//      c) RecvLogMessage -> FabricateMessage -> DropMessage 
//		as the manipulated message is dropped after fabricated
// 3: If one state is ReplayMessage, there also have three ways to make the log legal, 
//     combined with the previous and the next state of the present one, the order will be:
//      a) DropMessage -> ReplayMessage -> DropMessage
//              as the manipulated message is dropped after replayed and one more message dropping is considered normal condition due to task description
//      b) RecvLogMessage -> ReplayMessage -> DropMessage 
//		as the manipulated message is dropped after replayed
//      c) DropMessage -> ReplayMessage -> RecvLogMessage and the Message droped is equal to the message replayed
pred log_correct[s : State] {
 all s: State, s':ord/next[s], p': ord/prev[s] | some (s.log.elems) implies (
 (s.last_action = SendLogMessage or s.last_action = RecvLogMessage or s.last_action = DropMessage)
         or (s.last_action = FabricateMessage and s'.last_action = RecvLogMessage and p'.last_action = DropMessage and s'.network = p'.network)
 	  or (s.last_action = FabricateMessage and s'.last_action = DropMessage and p'.last_action = RecvLogMessage)
   	  or (s.last_action = FabricateMessage and s'.last_action = DropMessage and p'.last_action = DropMessage)
   	  or (s.last_action = ReplayMessage and s'.last_action = DropMessage and p'.last_action = DropMessage)
  	  or (s.last_action = ReplayMessage and s'.last_action = RecvLogMessage and p'.last_action = DropMessage and s'.network = p'.network)
   	  or (s.last_action = ReplayMessage and s'.last_action = DropMessage and p'.last_action = RecvLogMessage)
)}

// used to specify the log_correct_* predicates below
pred attacker_only[actions : AttackerAction] {
  all s : State | s.last_action in AttackerAction implies s.last_action in actions
}

assert log_correct_when_attacker_only_drops {
  all s : State | attacker_only[DropMessage] implies log_correct[s]
}
// <Adjust these thresholds as necessary to find the smallest
//  attack you can, when such an attack exists, in each attacker model>
check log_correct_when_attacker_only_drops for 10 expect 0

assert log_correct_when_attacker_only_replays {
  all s : State | attacker_only[ReplayMessage] implies log_correct[s]
}
// <Adjust these thresholds as necessary to find the smallest
//  attack you can, when such an attack exists, in each attacker model>
check log_correct_when_attacker_only_replays for 10 expect 1
// =========================== Task 3 ==================================
// The replay attack injects a message from the log 
// which previously appeared on the network but was unnecessarily received by Receiver onto the network.
// A possible example shown by Alloy is as below:
//
// State$0: network = empty, log = empty, last_action = empty
// State$1: network = LogMessage$1, log = empty, last_action = SendLogMessage
// State$2: network = empty, log = [0] LogMessage$1, last_action = RecvLogMessage
// State$3: network = LogMessage$0, log = [0] LogMessage$1, last_action = SendLogMessage
// State$4: network = empty, log = [0] LogMessage$1 -> [1] LogMessage$0, last_action = RecvLogMessage
// State$5: network = LogMessage$1, log = [0] LogMessage$1 -> [1] LogMessage$0, last_action = ReplayMessage
// State$6: network = empty, log = [0] LogMessage$1 -> [1] LogMessage$0 -> [2] LogMessage$1, last_action = RecvLogMessage
// 
// In the example above, State$5 replays LogMessage$1 from log 
// and adds it again on the network which is received by Receiver in State$6.
// In other words, the correct log should be: [0] LogMessage$1 -> [1] LogMessage$0, while the actual log after reply is: 
// [0] LogMessage$1 -> [1] LogMessage$0 -> [2] LogMessage$1. The attacker takes LogMessage$1 from log and replaces it
// on to the network, which is not sent by Sender. 
// Hence, the log contains a message that is not from Sender and becomes out of order thereof.

assert log_correct_when_attacker_only_fabricates {
  all s : State | attacker_only[FabricateMessage] implies log_correct[s]
}
// <Adjust these thresholds as necessary to find the smallest
//  attack you can, when such an attack exists, in each attacker model>
check log_correct_when_attacker_only_fabricates for 10 expect 1
// =========================== Task 3 ==================================
// The fabricate attack injects a new message from the log onto the network.
// The message can previously appear on the network or be a completely new one.
// A possible example shown by Alloy is as below:
//
// State$0: network = empty, log = empty, last_action = empty
// State$1: network = LogMessage$1, log = empty, last_action = SendLogMessage
// State$2: network = empty, log = [0] LogMessage$1, last_action = RecvLogMessage
// State$3: network = LogMessage$0, log = [0] LogMessage$1, last_action = SendLogMessage
// State$4: network = empty, log = [0] LogMessage$1 -> [1] LogMessage$0, last_action = RecvLogMessage
// State$5: network = LogMessage$0, log = [0] LogMessage$1 -> [1] LogMessage$0, last_action = FabricateMessage
// State$6: network = empty, log = [0] LogMessage$1 -> [1] LogMessage$0 -> [2] LogMessage$0, last_action = RecvLogMessage
// 
// In the example above, State$5 fabricates a new message named LogMessage$1 
// (from the log in this case, and it is likely to be LogMessage$3 as well)
// and adds it on the network which is received by Receiver in State$6.
// In other words, the correct log should be: [0] LogMessage$1 -> [1] LogMessage$0, while the actual log after reply is: 
// [0] LogMessage$1 -> [1] LogMessage$0 -> [2] LogMessage$0. The attacker adds a LogMessage$0
// onto the network, which is not sent by Sender. 
// Hence, the log contains a message that is not from Sender and becomes out of order thereof.

// =========================== Task 4 ==================================
// One possible uncaptured attack would be information disclosure. 
// Specifically, since a hacker can access the network, he is able to backup all the information online to a third-party database. 
// In other words, he can copy another “log” and keep on his own. 
// Though the original log is inaccessible to the hacker, yet he can steal the information
// by cutting out the messages on the network and save them in another medium. 
// In this case, he can reveal information to people who are not supposed to see it, including himself.
// One way to improve the model is to introduce a new type of attack action called “CopyMessage” to “log_correct” predication. 
// Whenever the hacker is trying to execute this attack action, the assertion will check and report it in Alloy. 
//
// Another type of attack that a hacker can perform is Denial of Service, which means the hacker try to crash the server. 
// For example, as the hacker could access to the network, he can continuously drop all the message sent from the sender. 
// In this case, the logging service continuously receives nothing and the correct log checking function will regard it as a normal phenomenon.
// To solve this problem, we need to adjust the model to compare the total number of message dropped, the total number of message sent and upload the upper bound of disagreement. 
// If the disagreement is so obvious that exceeds the bound, then we can detect our messages are lost unnormally.

